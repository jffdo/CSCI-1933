Method				ArrayList Runtime	LinkedList Runtime	Explanation
boolean add(T element)		O(1)/O(n)		O(1)			ArrayList has a complexity of 1 only if array is not full of elements. If the array is full, the method will need to double the size of the array causing the complexity to be n. Linked List has a complexity of 1, since it has an attribute called last. Which gets updated everytime the list is modified. Last is a pointer to the last node. 
boolean rotate(int n)		O(n)			O(n)			ArrayList has for loop iterates over the constant parameter, that also has a for loop moving the elements to the right which has a complexity of n. The worst case is when index 0 moves over the length of the list-1. The complexity being O(n-1), which simplifies to O(n). The LinkedList has a similar implementaion in which the head is also moved over to the right. Therefore alse having a complexity of O(n) 
void merge(List<T>otherList)	O(n+m)			O(n+m)			ArrayList itereates over both lists. Causing the complexity to be O(n+m), with m refering to the complexity of iterating over the other list. LinkedList also has a similar implementation with a complexity of O(n+m)
void reverse()			O(n)			O(n)			ArrayList swaps the first and last indices until the method reaches the middle. Causing the complexity to be O(1/2n), which simplifies to O(n). Linked list reverse method sets the pointer to the node next to be the new head. Then sets the pointer to be the trailers next node. Then incrementally moves the pointer and trailer of next node to the right. This will iterate over all elements of the list, causing the complexity to be O(n).